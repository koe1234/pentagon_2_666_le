//---------------------------------------------------------------------------
#include <vcl.h>
#include <stdio.h>
#include <conio.h>
#pragma hdrstop
#include "compress.h"
//---------------------------------------------------------------------------
#pragma argsused
//---------------------------------------------------------------------------
static char *default_var_name = "data_buffer";
static long  default_chunk_size = 32000;
//---------------------------------------------------------------------------
BOOL GenerateCCode(int FileHandle, const BYTE *Buffer, ULONG BufSize,
    const char *VarName, ULONG MaxChunkSize);
//---------------------------------------------------------------------------
//
// RBF2C Adaptive Compressor/Converter, Version 1.0
// Usage: rbf2c.exe <input.rbf> <output.c> [<var_name>] [<max_chunk_size>]
//           |         |           |           |            |
//        argv[0]    argv[1]     argv[2]     argv[3]      argv[4]
//

int main(int argc, char* argv[])
{
    printf("RBF2C Adaptive Compressor/Converter, Version 1.0\r\n");

    if(argc < 3)
    {
        printf("Usage: rbf2c.exe <input.rbf> <output.c> [<var_name>] [<max_chunk_size>]\r\n\r\n"
        	"Default <var_name> = \"%s\", default <max_chunk_size> = \"%i\"\r\n",
            default_var_name, default_chunk_size);
        return -1;
    }

    char *InputFilename = argv[1];
    char *OutputFilename = argv[2];
    char *VariableName = ((argc > 3) ? argv[3] : default_var_name);
    LONG MaxChunkSize = ((argc > 4) ? ::atol(argv[4]) : default_chunk_size);

    if(!FileExists(InputFilename))
    {
        printf("Error - Input file does not exist.\r\n");
        return -1;
    }

    int InputHandle = FileOpen(InputFilename, fmOpenRead);
    if(InputHandle == -1)
    {
        printf("Error - Unable to open input file.\r\n");
        return -1;
    }

    int OutputHandle = FileCreate(OutputFilename);
    if(OutputHandle == -1)
    {
        printf("Error - Unable to create output file.\r\n");
        FileClose(InputHandle);
        return -1;
    }

    ULONG OutputBufSize = 0;
    ULONG InputBufSize = GetFileSize((HANDLE)InputHandle, NULL);
    if(InputBufSize == 0)
    {
        printf("Error - Input file is empty.\r\n");
        FileClose(InputHandle);
        FileClose(OutputHandle);
        return -1;
    }

    BYTE *OutputBuffer = new BYTE[2 * InputBufSize];
    BYTE *InputBuffer = new BYTE[InputBufSize];

    if(!OutputBuffer || !InputBuffer)
    {
        printf("Error - Error allocating memory.\r\n");

        FileClose(InputHandle);
        FileClose(OutputHandle);
        if(InputBuffer) delete[]InputBuffer;
        if(OutputBuffer) delete[]OutputBuffer;

        return -1;
    }

    __try
    {
        if(FileRead(InputHandle, InputBuffer, InputBufSize) != (LONG)InputBufSize)
        {
            printf("Error - Unable to read input file.\r\n");
            return -1;
        }

        // Invert all bits before compressing
	 //	for(UINT i = 0; i < InputBufSize; i++)
      //  {
       // 	BYTE b = (BYTE)InputBuffer[i];
       //     InputBuffer[i] =
	  //			((b & 0x01) << 7) |
	 //			((b & 0x02) << 5) |
	  //			((b & 0x04) << 3) |
	 //			((b & 0x08) << 1) |
	  //			((b & 0x10) >> 1) |
	  //			((b & 0x20) >> 3) |
	    //			((b & 0x40) >> 5) |
	   //			((b & 0x80) >> 7) ;
       // }

        arithmetic_compress(InputBuffer, InputBufSize,
            OutputBuffer, &OutputBufSize);

        if(!GenerateCCode(OutputHandle, OutputBuffer,
            OutputBufSize, VariableName, MaxChunkSize))
        {
            printf("Error - Unable to write output file.\r\n");
            return -1;
        }

        printf("Input files successfully converted.\r\n\r\n"
            "Input file data size:\t%u bytes\r\n"
            "Output file data size:\t%u bytes\r\n"
            "Ratio:\t\t\t%.01f%%\r\n",
            InputBufSize,
            OutputBufSize,
            (float)OutputBufSize * 100.0 / InputBufSize);
    }
    __finally
    {
        FileClose(InputHandle);
        FileClose(OutputHandle);

        if(InputBuffer) delete[]InputBuffer;
        if(OutputBuffer) delete[]OutputBuffer;
    }

    return 0;
}

//---------------------------------------------------------------------------

static const char *file_header = {
    "/*--- This file was generated by rom2c Arithmetic Compressor/Converter v1.0 ---*/\r\n"
    "\r\n"
    };
static const char *file_starter = {
    "const unsigned char %s[] = {\r\n"
    };
static const char *file_ender = {
    "\r\n\t};\r\n"
    };
static const char *file_line = {
    "\r\n/*----------------------------------------------------------------------------*/\r\n"
    };

//---------------------------------------------------------------------------

static BOOL WriteString(int FileHandle, const char *string)
{
    int len = strlen(string);
    if(FileWrite(FileHandle, string, len) != len)
        return FALSE;

    return TRUE;
}

//---------------------------------------------------------------------------

static BOOL GenerateCCode(int FileHandle, const BYTE *Buffer,
    ULONG BufSize, const char *VarName, ULONG MaxChunkSize)
{
    char tmpbuf[256] = {0};
    const INT BytesPerLine = 10;
    ULONG NumOfChunks = ((BufSize + MaxChunkSize - 1) / MaxChunkSize);

    if(!WriteString(FileHandle, file_header))
        return FALSE;

    if(NumOfChunks > 1)
    {
	    sprintf(tmpbuf, "/* Total number of chunks: %i */\r\n", NumOfChunks);
    	if(!WriteString(FileHandle, tmpbuf))
        	return FALSE;
	    sprintf(tmpbuf, "/* Maximum chunk size: %i */\r\n", MaxChunkSize);
    	if(!WriteString(FileHandle, tmpbuf))
        	return FALSE;
	   	if(!WriteString(FileHandle, "\r\n"))
    	   	return FALSE;
    }

    for(ULONG ch = 0; ch < NumOfChunks; ch++)
    {
        static char varname_and_index[256];
        if(NumOfChunks == 1)	sprintf(varname_and_index, "%s", VarName);
        else					sprintf(varname_and_index, "%s%i", VarName, (ch + 1));

        sprintf(tmpbuf, file_starter, varname_and_index);
        if(!WriteString(FileHandle, tmpbuf))
            return FALSE;

        ULONG chunk_start_offset = ch * MaxChunkSize;
        ULONG chunk_size = ((ch == (NumOfChunks - 1)) ?
            (BufSize % MaxChunkSize) : MaxChunkSize);

        for(ULONG i = 0; i < chunk_size; i++)
        {
            BOOL IsFirstByteInString = ((i % BytesPerLine) == 0);
            BOOL IsLastByteInString  = ((i % BytesPerLine) == (BytesPerLine - 1));
            BOOL IsDelimiterPresent  = (i < (chunk_size - 1));

            sprintf(tmpbuf, "%s0x%02x%s%s",
                (IsFirstByteInString ? "\t" : ""),
                Buffer[chunk_start_offset + i],
                (IsDelimiterPresent ? "," : ""),
                (IsLastByteInString ? "\r\n" : " "));

            if(!WriteString(FileHandle, tmpbuf))
                return FALSE;
        }

        if(!WriteString(FileHandle, file_ender))
            return FALSE;

        if(!WriteString(FileHandle, file_line))
            return FALSE;

        sprintf(tmpbuf, "\r\nconst unsigned long %s_size = %uL;\t/* chunk size, bytes */\r\n",
   	        varname_and_index, chunk_size);
        if(!WriteString(FileHandle, tmpbuf))
            return FALSE;

        if(!WriteString(FileHandle, file_line))
            return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------

